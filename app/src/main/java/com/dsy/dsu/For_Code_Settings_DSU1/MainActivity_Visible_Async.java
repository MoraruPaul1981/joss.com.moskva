package com.dsy.dsu.For_Code_Settings_DSU1;import android.app.Activity;import android.app.ActivityManager;import android.content.ComponentName;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.content.SharedPreferences;import android.content.pm.ActivityInfo;import android.database.sqlite.SQLiteCursor;import android.graphics.Color;import android.graphics.drawable.Drawable;import android.os.Bundle;import android.os.Handler;import android.os.IBinder;import android.os.Looper;import android.os.Message;import android.util.Log;import android.view.Gravity;import android.view.MenuItem;import android.view.View;import android.view.WindowManager;import android.view.animation.Animation;import android.view.animation.AnimationUtils;import android.view.animation.Interpolator;import android.widget.ImageView;import android.widget.ProgressBar;import android.widget.TextView;import android.widget.Toast;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import androidx.constraintlayout.widget.ConstraintLayout;import androidx.drawerlayout.widget.DrawerLayout;import androidx.loader.content.AsyncTaskLoader;import androidx.loader.content.Loader;import com.dsy.dsu.AllDatabases.CREATE_DATABASE;import com.dsy.dsu.Business_logic_Only_Class.Class_GRUD_SQL_Operations;import com.dsy.dsu.Business_logic_Only_Class.Class_Generation_Errors;import com.dsy.dsu.Business_logic_Only_Class.Class_MODEL_synchronized;import com.dsy.dsu.Business_logic_Only_Class.PUBLIC_CONTENT;import com.dsy.dsu.Code_For_Services.ServiceUpdatePoОбновлениеПО;import com.dsy.dsu.Code_For_Services.Service_For_Remote_Async_Binary;import com.dsy.dsu.R;import com.google.android.material.navigation.NavigationView;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.List;import java.util.Locale;import java.util.Random;import java.util.TimeZone;import java.util.concurrent.ExecutionException;import java.util.concurrent.Executors;import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;import io.reactivex.rxjava3.core.Flowable;import io.reactivex.rxjava3.functions.Action;import io.reactivex.rxjava3.functions.Supplier;import io.reactivex.rxjava3.schedulers.Schedulers;public class MainActivity_Visible_Async extends AppCompatActivity  {    private   Date ДатаДляИзмененияВерсииДанныхНаАндройде;    private  ProgressBar progressBarCycle;    private TextView Проценты;    private TextView textViewТекущийПользовательПРиВизуальнойСинхронизации;    private Integer ПолученныйПубличныйID = 0;    private  Boolean  ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ=false;    private  CREATE_DATABASE Create_Database_СсылкаНАБазовыйКласс;    private  Activity activity;    private  String РежимПерваяЗапускПослеPasswordИлиПовторная = new String();    private   PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков = null;    private   Integer ПубличноеIDПолученныйИзСервлетаДляUUID = 0;    private DrawerLayout drawerLayoutAsync;    private NavigationView navigationViewAsyncApp;    private       ImageView imageView_ЗначекAsync;    private  TextView ТекущаяТаблицыИлиГод;    private SharedPreferences preferences;    private Animation animation;    private Message messagePingUpdatePO;    private ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО localBinderОбновлениеПО;//TODO нова    private    ServiceConnection serviceConnectionAsync;    private  Message message;  //  private Service_For_Remote_Async.LocalBinderAsync localBinderAsync;//TODO нова    private Service_For_Remote_Async_Binary.LocalBinderAsync localBinderAsync;//TODO нова    private  ConstraintLayout LineLayFaceApp;    private    ServiceConnection connectionОбновлениеПО;    Boolean         ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна=false;    @Override    protected void onCreate(Bundle savedInstanceState) {        try{            super.onCreate(savedInstanceState);            setContentView(R.layout.activity_main__sinfrozisaziy__prograssbar);            МетодСитемныйНастройкиЭкран();            // TODO: 15.09.2021 ПРИШЕЛ ПАРАМЕНТ КАКУЮ НУЖНО ЗАПИСТИТЬ СИНХРОНИЗАЦИЮ           // preferences = PreferenceManager.getDefaultSharedPreferences(this);            preferences = getSharedPreferences("sharedPreferencesХранилище", Context.MODE_MULTI_PROCESS);            Intent     Интент_AsyncApp=getIntent();            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT(getApplicationContext());            РежимПерваяЗапускПослеPasswordИлиПовторная = preferences.getString("РежимЗапускаСинхронизации","");            if(РежимПерваяЗапускПослеPasswordИлиПовторная==null){                РежимПерваяЗапускПослеPasswordИлиПовторная=  "СамыйПервыйЗапускСинхронизации";            }            ///TODO принудительно устанвливаем редим работы синхронизации            Log.d(this.getClass().getName(), " КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная "+ РежимПерваяЗапускПослеPasswordИлиПовторная);            Create_Database_СсылкаНАБазовыйКласс=new CREATE_DATABASE(getApplicationContext());            ///TODO КОНТЕКСТ КОТОРЫЙ ПЕРЕДАЮТ ПО ВСЕЙ СИНХРОНИЗАЦИИИ НА ВСЕ ПРИЛОЖЕНИЕ            activity =this;            ((Activity) activity).setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);            ((Activity) activity) .setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);            /////todo данная настрока запрещает при запуке активти подскаваать клавиатуре вверх на компонеты eedittext            //////todo  конец настрока экран////todo запрещает поворот экрана            Log.d(this.getClass().getName(), "Сработал  protected void onCreate(Bundle savedInstanceState)  MainActivity_Visible_Async" );            getSupportActionBar().hide(); ///скрывать тул бар            progressBarCycle =(ProgressBar) findViewById(R.id.progressBar4ПоКругуСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            Drawable drawableЗаписьДанных = getResources().getDrawable(R.drawable.brograssbarnews2);///            progressBarCycle.setProgressDrawable(drawableЗаписьДанных);            Проценты =(TextView) findViewById(R.id.TextViewДляProgressBarГлавнойСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            textViewТекущийПользовательПРиВизуальнойСинхронизации=(TextView) findViewById(R.id.textViewТекущийПользовательПРиВизуальнойСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            navigationViewAsyncApp    = (NavigationView) findViewById(R.id.navigator_asyncapp); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            imageView_ЗначекAsync = (ImageView) findViewById(R.id.imageView_icon_asynsapp);            drawerLayoutAsync = (DrawerLayout) findViewById(R.id.drawerLayout_async_prograsser); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            LineLayFaceApp    = (ConstraintLayout) findViewById(R.id.LineLayFaceApp);            drawerLayoutAsync.setBackgroundColor(Color.WHITE);         //TODO устанвливает цвета            drawerLayoutAsync.setBackgroundColor(Color.WHITE);            drawerLayoutAsync.setDrawingCacheBackgroundColor(Color.RED);//todo            ТекущаяТаблицыИлиГод = (TextView) findViewById(R.id.TExtViewНазваниеКонторыСнизуСинх); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            // animation = AnimationUtils.loadAnimation(getContext(), R.anim.slide_in_row_vibrator1);            animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.slide_in_row_vibrator1);            // TODO: 25.10.2022 востанавливаем данных после поворота экрана            if(savedInstanceState!=null){                Проценты.setText(savedInstanceState.getString("Проценты"));                ТекущаяТаблицыИлиГод.setText(savedInstanceState.getString("ТекущаяТаблицыИлиГод"));                progressBarCycle.setProgress(savedInstanceState.getInt("progressBar4Cycle"));                progressBarCycle.setMax(savedInstanceState.getInt("progressBar4CycleMAx"));            }            МетодБиндингаRemoteAsync( );            МетодИнициализацияMessager();            // TODO: 09.10.2022 запуск слушателядоковой панели            МетодДляСлушательБоковойПанелиAsyncApp();            МетодДоНачалаСинхрониазцииExecutor();///TODO ДО СИНХРОНИАЗЦИИ            // TODO: 25.03.2023            Log.d(this.getClass().getName(),"\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber());        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    protected void onStop() {        super.onStop();        try{            Log.d(this.getClass().getName(), "\n" + " class " +                    Thread.currentThread().getStackTrace()[2].getClassName()                    + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void методUnBindingСлужбыОбновления() {        try {            if (serviceConnectionAsync!=null) {                unbindService(serviceConnectionAsync);            }            if(connectionОбновлениеПО!=null){                unbindService(connectionОбновлениеПО);            }            Log.d(this.getClass().getName(),"\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"  + " serviceConnectionAsync " +serviceConnectionAsync+                      " localBinderAsync "+ localBinderAsync + " localBinderОбновлениеПО  " +localBinderОбновлениеПО);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onDestroy() {        super.onDestroy();        try{            Log.d(this.getClass().getName(),"\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодБиндингаRemoteAsync( ) {        try {            // TODO: 28.04.2023  запускаем Гланвную Синхрониазцию              //  Intent intentОбноразоваяСинхронизациия = new Intent(getApplicationContext(), Service_For_Remote_Async.class);                Intent intentОбноразоваяСинхронизациия = new Intent(getApplicationContext(), Service_For_Remote_Async_Binary.class);                intentОбноразоваяСинхронизациия.setAction("com.StartingAsyncMainBackgroud");                serviceConnectionAsync=     new ServiceConnection() {                    @Override                    public void onServiceConnected(ComponentName name, IBinder service) {                        try{                            if (service.isBinderAlive()) {                            //    localBinderAsync = (Service_For_Remote_Async.LocalBinderAsync) service;                                Boolean ФлагRuntimeAsyncServiceRemote     =  методПринитияРешенияЗапускаRemoteAsync();                                if (ФлагRuntimeAsyncServiceRemote==true) {                                    localBinderAsync = (Service_For_Remote_Async_Binary.LocalBinderAsync) service;                                    МетодБиндингаОбновлениеПО();                                }                                Log.d(this.getClass().getName(), "\n" + " class " +                                        Thread.currentThread().getStackTrace()[2].getClassName()                                        + "\n" +                                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                                        + " localBinderlocalBinderAsync.isBinderAlive()Async " + localBinderAsync.isBinderAlive() +                                        " ФлагRuntimeAsyncServiceRemote" +ФлагRuntimeAsyncServiceRemote);                            }                        } catch (Exception e) {                            e.printStackTrace();                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                    + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                    Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                    }                    @Override                    public void onServiceDisconnected(ComponentName name) {                        localBinderAsync =null;                        Log.d(getApplicationContext().getClass().getName().toString(), "\n"                                + "onServiceConnected  одноразовая  messengerActivity  " );                    }                    @Override                    public void onBindingDied(ComponentName name) {                        ServiceConnection.super.onBindingDied(name);                    }                    @Override                    public void onNullBinding(ComponentName name) {                        ServiceConnection.super.onNullBinding(name);                    }                };         Boolean asBoolenCbyСинхронная=       bindService(intentОбноразоваяСинхронизациия, serviceConnectionAsync ,Context.BIND_AUTO_CREATE);            // TODO: 28.04.2023            Log.d(this.getClass().getName(), "\n" + " class " +                    Thread.currentThread().getStackTrace()[2].getClassName()                    + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"  + " asBoolenCbyСинхронная " +asBoolenCbyСинхронная);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());            Log.d(this.getClass().getName(), "  Полусаем Ошибку e.toString() " + e.toString());        }    }    private void методЗапускаОбновлениеПо() {        try{            localBinderОбновлениеПО.getService().МетодГлавныйОбновленияПО(true,activity,message);            Log.i(this.getClass().getName(),  " Атоманически установкаОбновление ПО "+                    Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );            Log.i(this.getClass().getName(),  "R.id.item_async_updatepo  "                    +Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private Boolean методЗапускаОбновлениеПоИзAsync() {        try{          ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна=      localBinderОбновлениеПО.getService().МетодГлавныйОбновленияПОДоAsync(true,activity,message);            Log.i(this.getClass().getName(),  " Атоманически установкаОбновление ПО "+                    Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );            Log.i(this.getClass().getName(),  "R.id.item_async_updatepo  "                    +Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() +                     "ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна " +ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        return  ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна;    }    @NonNull    private  Boolean методПринитияРешенияЗапускаRemoteAsync() {        Boolean ФлагRuntimeAsyncServiceRemote=true;        try{        ActivityManager am = (ActivityManager)this.getSystemService(ACTIVITY_SERVICE);        List<ActivityManager.RunningServiceInfo> ЗапущенныеСлужбы = am.getRunningServices(50);        if(ЗапущенныеСлужбы.size()>0){            for (int i = 0; i < ЗапущенныеСлужбы.size(); i++) {                ActivityManager.RunningServiceInfo runningServiceInfo=       ЗапущенныеСлужбы.get(i);                if(runningServiceInfo.service.getClassName().equalsIgnoreCase("com.dsy.dsu.Code_For_Services.Service_For_Remote_Async")){                    if(runningServiceInfo.started==true || runningServiceInfo.clientCount>1){                        ФлагRuntimeAsyncServiceRemote=false;                    }                    Log.d(this.getClass().getName(), "\n" + " class " +                            Thread.currentThread().getStackTrace()[2].getClassName()                            + "\n" +                            " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                            " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                            + " localBinderlocalBinderAsync.isBinderAlive()Async " + localBinderAsync.isBinderAlive() +                            "runningServiceInfo " +runningServiceInfo+"Process " + runningServiceInfo.process +                            " with component " + runningServiceInfo.service.getClassName() +                            "runningServiceInfo.started " +runningServiceInfo.started +                            " runningServiceInfo.clientCount "+ runningServiceInfo.clientCount);                }            }        }    } catch (Exception e) {        e.printStackTrace();        Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                + Thread.currentThread().getStackTrace()[2].getLineNumber());        new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                Thread.currentThread().getStackTrace()[2].getLineNumber());    }        return ФлагRuntimeAsyncServiceRemote;    }    private void МетодСитемныйНастройкиЭкран() {        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD                | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);        //////todo настрока экрана        getWindow().getDecorView().setSystemUiVisibility(                View.SYSTEM_UI_FLAG_LAYOUT_STABLE                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION                        | View.SYSTEM_UI_FLAG_FULLSCREEN                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);        getSupportActionBar().setHomeButtonEnabled(false);        getSupportActionBar().setDisplayHomeAsUpEnabled(false);        getSupportActionBar().setHomeAsUpIndicator(null);    }    @Override    protected void onRestart() {        super.onRestart();        try {            if(preferences!=null){                МетодСитемныйНастройкиЭкран();                // TODO: 26.10.2022                МетодВостановлениеЭкранаПослеПоворота();            }            Log.d(this.getClass().getName(), "onRestart");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодВостановлениеЭкранаПослеПоворота() {        try{            if(Проценты.isAttachedToWindow()){                Проценты.setText(preferences.getString("Проценты",""));                ТекущаяТаблицыИлиГод.setText(preferences.getString("ТекущаяТаблицыИлиГод",""));                progressBarCycle.setProgress(preferences.getInt("progressBar4Cycle",0));                progressBarCycle.setMax(preferences.getInt("progressBar4CycleMAx",0));                // TODO: 02.05.2023 экран перегружаем                Проценты.requestLayout();                ТекущаяТаблицыИлиГод.requestLayout();                progressBarCycle.requestLayout();                drawerLayoutAsync.refreshDrawableState();                Log.d(getApplicationContext().getClass().getName(), "\n"                        + " время: " + new Date() + "\n+" +                        " Класс в процессе... " + this.getClass().getName() + "\n" +                        " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                        + "    preferences.getString(\"Проценты\",\"\") "+preferences.getString("Проценты",""));            }        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onStart() {        super.onStart();//////TODO ловим поворот экрана  ДЛЯ СИНХРОНИЗАЦИИ        try{            МетодБоковаяПанельОткрытьЗАкрыть();            Log.i(this.getClass().getName(), "ДО  ОТРАБОТАННЙ СИНХРОНИЗАЦИИ ВИЗУАЛЬНОЙ doInBackground asyncTaskГлавныйДляСинхронизации ");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onResume() {        super.onResume();        try{        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                    Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 26.10.2022 сохраняет данные    protected void onSaveInstanceState(Bundle outState) {        try{            Log.i(this.getClass().getName(), "onSaveInstanceState ");            outState.putString("Проценты",  Проценты.getText().toString());            outState.putString("ТекущаяТаблицыИлиГод",  ТекущаяТаблицыИлиГод.getText().toString());            outState.putInt("progressBar4Cycle",   progressBarCycle.getProgress());            outState.putInt("progressBar4CycleMAx",   progressBarCycle.getMax());            // TODO: 26.10.2022            SharedPreferences.Editor editor = preferences.edit();            editor.putString("Проценты",   Проценты.getText().toString());            editor.putString("ТекущаяТаблицыИлиГод", ТекущаяТаблицыИлиГод.getText().toString());            editor.putInt("progressBar4Cycle",   progressBarCycle.getProgress());            editor.putInt("progressBar4CycleMAx",   progressBarCycle.getMax());            editor.commit();// This will async            super.onSaveInstanceState(outState);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 26.10.2022 воставливает данные    protected void onRestoreInstanceState(Bundle savedInstanceState) {        super.onRestoreInstanceState(savedInstanceState);        try {            Log.i(this.getClass().getName(), "onRestoreInstanceState ");            МетодСитемныйНастройкиЭкран();            // TODO: 25.10.2022 востанавливаем данных после поворота экрана            МетодВостановлениеЭкранаПослеПоворота();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    public void onBackPressed()    {        //thats it    }    protected Integer МетодЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму() {        Integer Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации=0;        try{            ContentValues КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил = new ContentValues();            Date Дата = Calendar.getInstance().getTime();            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", new Locale("ru"));//"yyyy-MM-dd HH:mm:ss.SSS"//"yyyy-MM-dd'T'HH:mm:ss'Z'"            dateFormat.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            Log.d(this.getClass().getName(), " ГЛАВНАЯ ДАТА ПРОГРАММЫ ДСУ-1 : " + dateFormat.format(Дата));            String ДатаДляПоказываетУспешнойСинхрониазцииЧтоПользовательЗаходилВпрограмму = dateFormat.format(Дата);            КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил.put("date_update", ДатаДляПоказываетУспешнойСинхрониазцииЧтоПользовательЗаходилВпрограмму);            Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ= new Class_GRUD_SQL_Operations(getApplicationContext());            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.concurrentHashMapНабор.put("СамFreeSQLКОд",                    " SELECT id  FROM successlogin  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            PUBLIC_CONTENT  Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT (getApplicationContext());            SQLiteCursor            Курсор_ПолучаемПубличныйID= (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                    new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.concurrentHashMapНабор,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков                    ,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            if(Курсор_ПолучаемПубличныйID.getCount()>0){                Курсор_ПолучаемПубличныйID.moveToFirst();                ПубличноеIDПолученныйИзСервлетаДляUUID=         Курсор_ПолучаемПубличныйID.getInt(0);                Log.d(this.getClass().getName(), " ID  " + ПубличноеIDПолученныйИзСервлетаДляUUID);            }            Log.d(this.getClass().getName(), " ID  " + ПубличноеIDПолученныйИзСервлетаДляUUID);            if ( ПубличноеIDПолученныйИзСервлетаДляUUID>0) {                Class_GRUD_SQL_Operations class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму = new Class_GRUD_SQL_Operations(getApplicationContext());                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНабор.put("НазваниеОбрабоатываемойТаблицы", "SuccessLogin");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНабор.put("Флаг_ЧерезКакоеПолеОбновлением", "id");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНабор.put("ЗначениеФлагОбновления", ПубличноеIDПолученныйИзСервлетаДляUUID);                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНабор.put("ЗнакФлагОбновления", "=");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        contentValuesДляSQLBuilder_Для_GRUD_Операций.putAll(КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил);                Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации = (Integer) class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        new UpdateData(getApplicationContext()).updatedata(class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.concurrentHashMapНабор,                        class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.contentValuesДляSQLBuilder_Для_GRUD_Операций,                        Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());                Log.d(this.getClass().getName(), " Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации"                        + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);                // TODO: 08.09.2021  resultat                if (Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации > 0) {                    Log.d(getApplicationContext().getClass().getName(), " Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации " + "--"                            + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/////                } else {                    Log.d(getApplicationContext().getClass().getName(), " NO Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации " + "--"                            + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/////                }            }        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        return  Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации;    }    ///TODO вычисляем если такая таблиЦА ВНУТРИ БАЗЫ    protected boolean МетодВЫчисляемВсеТаблицыВнутриКлинета(String ТекущаяТаблицаДляОБменаДанными) {        ////        boolean ЕслиТАкаяТаблица = false;        ////        SQLiteCursor КурсорВсехТаблицВнутри=null;        try{            // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ            Class_GRUD_SQL_Operations     class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета=new Class_GRUD_SQL_Operations(getApplicationContext());            ///            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета.concurrentHashMapНабор.put("НазваниеОбрабоатываемойТаблицы","sqlite_master");            ///////            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета.concurrentHashMapНабор.put("СтолбцыОбработки","name");            //            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета.concurrentHashMapНабор.put("ФорматПосика","type = 'table' ");            ///"_id > ?   AND _id< ?"            //////             /*       class_grud_sql_operations. concurrentHashMapНабор.put("УсловиеПоиска1",finalПолученныйUUID);                    ///                    class_grud_sql_operations. concurrentHashMapНабор.put("УсловиеПоиска2","Удаленная");                    ///                    class_grud_sql_operations. concurrentHashMapНабор.put("УсловиеПоиска3",МЕсяцДляКурсораТабелей);                    //                    class_grud_sql_operations. concurrentHashMapНабор.put("УсловиеПоиска4",ГодДляКурсораТабелей);////УсловиеПоискаv4,........УсловиеПоискаv5 .......*/            ////TODO другие поля            ///classGrudSqlOperations. concurrentHashMapНабор.put("ПоляГрупировки",null);            ////            //class_grud_sql_operations. concurrentHashMapНабор.put("УсловиеГрупировки",null);            ////            // class_grud_sql_operationsПолучениеИмяСистемы. concurrentHashMapНабор.put("УсловиеСортировки","date_update");            ////            /// class_grud_sql_operations. concurrentHashMapНабор.put("УсловиеЛимита","1");            ////            // TODO: 27.08.2021  ПОЛУЧЕНИЕ ДАННЫХ ОТ КЛАССА GRUD-ОПЕРАЦИИ            КурсорВсехТаблицВнутри=null;            КурсорВсехТаблицВнутри= (SQLiteCursor)  new Class_GRUD_SQL_Operations(getApplicationContext()).                    new GetData(getApplicationContext()).getdata(class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета.concurrentHashMapНабор,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков                    ,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            Log.d(this.getClass().getName(), "GetData "  +КурсорВсехТаблицВнутри);    /*            // TODO: 08.09.2021 ____old                /////              КурсорВсехТаблицВнутри=ССылкаНаСозданнуюБазу.rawQuery("SELECT name FROM sqlite_master WHERE type = 'table'",null);*/            // TODO: 08.09.2021 resultat            if(КурсорВсехТаблицВнутри.getCount()>0) {                КурсорВсехТаблицВнутри.moveToFirst();                Log.d(this.getClass().getName(), "  КурсорВсехТаблицВнутри."  +  КурсорВсехТаблицВнутри.getCount());                // TODO: 08.09.2021  цикл                do {                    ////                    if (ТекущаяТаблицаДляОБменаДанными.equals(КурсорВсехТаблицВнутри.getString(0))) {                        Log.d(this.getClass().getName(), "  ТекущаяТаблицаДляОБменаДанными." + ТекущаяТаблицаДляОБменаДанными +                                "  КурсорВсехТаблицВнутри.getString(0)) " + КурсорВсехТаблицВнутри.getString(0));                        ЕслиТАкаяТаблица = true;                        break;                    }                    Log.d(this.getClass().getName(), "  ТекущаяТаблицаДляОБменаДанными." + ТекущаяТаблицаДляОБменаДанными +                            "  КурсорВсехТаблицВнутри.getString(0)) " + КурсорВсехТаблицВнутри.getString(0));                }while(КурсорВсехТаблицВнутри.moveToNext());                ////////                КурсорВсехТаблицВнутри.close();            }else{                Log.d(this.getClass().getName(), "  КурсорВсехТаблицВнутри."  +  КурсорВсехТаблицВнутри.getCount());                //////                ЕслиТАкаяТаблица=false;            }            ///todo публикум название таблицы или цифру его        } catch (Exception e) {            //  Block of code to handle errors            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }////        return ЕслиТАкаяТаблица;    }    void МетодПоказываетЗаблокированЛИПользовательИЛИнетСтатусОтСервера(PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков) throws ExecutionException, InterruptedException {        try {            Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ;            // TODO: 28.07.2022 проверка заблокирован ли пользователь или нет            //TODO  ПРОВЕРЯЕМ ТЕКУЩИЙ ПОЛЬЗОВАТЕЛЬ МОЖНО РАБОТАТЬ ИЛИ ОН ЗАБЛОКИРОВАН            ///            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ=new Class_GRUD_SQL_Operations(getApplicationContext());            // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ            ///            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.concurrentHashMapНабор.put("СамFreeSQLКОд",                    " SELECT locked  FROM chat_users  WHERE _id= '"+ПолученныйПубличныйID+"'  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            Integer ПолученныйСтатусТекущегоПользователя=0;            SQLiteCursor            Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором=null;            ///////            Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором=                    (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                            new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                                    concurrentHashMapНабор,                            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,                            Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            Log.d(this.getClass().getName(), " Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount() "                    +Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount());            if ( Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount()>0 ){                Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.moveToNext();                ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ= Boolean.parseBoolean(Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getString(0))        ;            }            // TODO: 28.07.2022            Log.d(this.getClass().getName(), " ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ "                    +ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ);        } catch (Exception e) {            //  Block of code to handle errors            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    void МетодДоНачалаСинхрониазцииExecutor() {        try{            ДатаДляИзмененияВерсииДанныхНаАндройде = Calendar.getInstance().getTime();            Log.d(this.getClass().getName(), " onStartLoading() начало метода  ");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                    " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(),                    Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 02.09.2021  метод Визуализация    private void МетодИнициализацияMessager() {        try{            message=Message.obtain(new Handler(Looper.myLooper()),()->{                try {                    Bundle bundleCallsBackAsynsService=message.getData();                    switch (message.what){                        case 2:// процеессе                            МетодВизуализацииСинхронизации(bundleCallsBackAsynsService);                            break;                        case 7:// процеессе                            message.getTarget().post(()-> {                                if (   progressBarCycle.isAttachedToWindow()) {                                    progressBarCycle.setInterpolator(new Interpolator() {                                        @Override                                        public float getInterpolation(float input) {                                            return 50;                                        }                                    });                                    Drawable drawableЗаписьДанных = getResources().getDrawable(R.drawable.brograssbarnews3);///                                    progressBarCycle.setProgressDrawable(drawableЗаписьДанных);                                    progressBarCycle.requestLayout();                                    progressBarCycle.refreshDrawableState();                                }                            });                            break;                    }                    Log.d(this.getClass().getName(), "\n" + " class " +                            Thread.currentThread().getStackTrace()[2].getClassName()                            + "\n" +                            " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                            " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                            + " message.what " +message.what  + "bundleCallsBackAsynsService "+bundleCallsBackAsynsService);                } catch (Exception e) {                    e.printStackTrace();                    Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                            + Thread.currentThread().getStackTrace()[2].getLineNumber());                    new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                            this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                            Thread.currentThread().getStackTrace()[2].getLineNumber());                }                Log.i(this.getClass().getName(),  " Атоманически установкаОбновление ПО "+                        Thread.currentThread().getStackTrace()[2].getMethodName()+                        " время " +new Date().toLocaleString() + " localBinderОбновлениеПО " +localBinderОбновлениеПО );            });            Log.i(getApplicationContext().getClass().getName(),  " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"  );        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодВизуализацииСинхронизации( @NonNull  Bundle bundleCallsBackAsynsService) {        try{                    message.getTarget().post(()->{                        if (   progressBarCycle.isAttachedToWindow()) {                            Drawable drawable = getResources().getDrawable(R.drawable.brograssbarnews2);///                            progressBarCycle.setProgressDrawable(drawable);                            Integer ПроцентыNew = bundleCallsBackAsynsService.getInt( "Проценны", 0);                            String ИмяТаблица = bundleCallsBackAsynsService.getString("имятаблицы", "");                            Integer MaxКоличествоСТрочеек = bundleCallsBackAsynsService.getInt("maxtables", 0);                            Integer CurrentPotionСТрочеек = bundleCallsBackAsynsService.getInt("currentposition", 0);                            ТекущаяТаблицыИлиГод.setHint(ИмяТаблица);                            Integer ПроцентыOld= 0;                            if (Проценты.getText()!=null) {                                ПроцентыOld = Integer.parseInt(Проценты.getText().toString().replaceAll("([^0-9])", "")) ;                            }                            if (ПроцентыNew>ПроцентыOld  && ПроцентыNew>0 ) {                                Проценты.setText(ПроцентыNew+"%");                            } else {                                Проценты.setText(ПроцентыOld+"%");                            }                            progressBarCycle.setMax(MaxКоличествоСТрочеек);                            CurrentPotionСТрочеек=CurrentPotionСТрочеек+1;                            if (CurrentPotionСТрочеек>=progressBarCycle.getProgress()) {                                progressBarCycle.setProgress(CurrentPotionСТрочеек);                            }                            Log.d(this.getClass().getName(), "\n" + " class " +                                    Thread.currentThread().getStackTrace()[2].getClassName()                                    + "\n" +                                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                                    + " Проценты.getText().toString() " + Проценты.getText().toString());                            Проценты.requestLayout();                            ТекущаяТаблицыИлиГод.requestLayout();                            progressBarCycle.requestLayout();                            // TODO: 04.05.2023  disayn                            Проценты.refreshDrawableState();                            ТекущаяТаблицыИлиГод.refreshDrawableState();                            progressBarCycle.refreshDrawableState();                        }                    });        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодБоковаяПанельОткрытьЗАкрыть() {        try {            if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                drawerLayoutAsync.closeDrawer(Gravity.LEFT);            }        } catch (Exception e) {            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 03.04.2022    private void МетодДляСлушательБоковойПанелиAsyncApp() {        // TODO: 06.04.2022        try {            imageView_ЗначекAsync.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    if (navigationViewAsyncApp.isShown()) {                        navigationViewAsyncApp.setVisibility(View.GONE);                        if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                            drawerLayoutAsync.closeDrawer(Gravity.LEFT);                        }                    } else {                        navigationViewAsyncApp.setVisibility(View.VISIBLE);                        if (!drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                            drawerLayoutAsync.openDrawer(Gravity.LEFT);                        }                    }                }            });            drawerLayoutAsync.addDrawerListener(new DrawerLayout.SimpleDrawerListener() {                @Override                public void onDrawerOpened(View drawerView) {                    Drawable drawable = getResources().getDrawable(R.mipmap.icon_dsu1_for_asyncapp_close_naviga);///                    imageView_ЗначекAsync.setImageDrawable(drawable);                    navigationViewAsyncApp.setVisibility(View.VISIBLE);                    super.onDrawerOpened(drawerView);                }                @Override                public void onDrawerClosed(View drawerView) {                    Drawable drawable = getResources().getDrawable(R.drawable.icon_dsu1_async_asynprograssbar);///                    imageView_ЗначекAsync.setImageDrawable(drawable);                    navigationViewAsyncApp.setVisibility(View.GONE);                    super.onDrawerClosed(drawerView);                }            });            navigationViewAsyncApp.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {                @Override                public boolean onNavigationItemSelected(@NonNull MenuItem item) {                    switch (item.getItemId()) {                        // TODO: 06.04.2022 Запускаем ОШибки                        case R.id.one:                            item.setChecked(true);                            Log.w(getPackageName().getClass().getName(), "item.getItemId() Посмотреть ошибки   " + item.getItemId() + "\n");//////////                            try {                                Intent Интент_Меню = new Intent(getApplication(), MainActivity_Errors.class);                                Интент_Меню.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);//////FLAG_ACTIVITY_SINGLE_TOP                                Log.d(this.getClass().getName(), "" + "case R.id.ПунктМенюПервый:");                                startActivity(Интент_Меню);                                Log.i(this.getClass().getName(),  "R.id.one "+Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );                            } catch (Exception e) {                                e.printStackTrace();                                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                            break;                        // TODO: 06.04.2022 ЗапускаемОбновление ПО                        case R.id.item_async_updatepo:                            item.setChecked(true);                            try {// TODO: 10.07.2023  запуск обновление ПО                                методЗапускаОбновлениеПо();                                Log.i(this.getClass().getName(),  " Атоманически установкаОбновление ПО "+ Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );                                Log.w(getPackageName().getClass().getName(), "item.getItemId() Посмотреть ошибки   " + item.getItemId() + "\n");//////////                                Log.i(this.getClass().getName(),  "R.id.item_async_updatepo  "+Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );                            } catch (Exception e) {                                e.printStackTrace();                                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                            break;                    }                    if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                        drawerLayoutAsync.closeDrawer(Gravity.LEFT);                    }                    return true;                }            });        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        // TODO: 04.04.2022    }    private void МетодПослеСинхрониазцииЗапускаемИОцениваемПользователя()           {        try{            PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков=new PUBLIC_CONTENT(getApplicationContext());            Class_GRUD_SQL_Operations class_grud_sql_operations = new Class_GRUD_SQL_Operations(getApplicationContext());            class_grud_sql_operations.concurrentHashMapНабор.put("СамFreeSQLКОд",                    " SELECT id  FROM successlogin  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            SQLiteCursor Курсор_ПолучаемПубличныйID = null;            Курсор_ПолучаемПубличныйID = (SQLiteCursor) class_grud_sql_operations.                    new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operations.                            concurrentHashMapНабор,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков, new CREATE_DATABASE(getApplicationContext()).getССылкаНаСозданнуюБазу());            if (Курсор_ПолучаемПубличныйID.getCount() > 0) {                Курсор_ПолучаемПубличныйID.moveToFirst();                ПолученныйПубличныйID = Курсор_ПолучаемПубличныйID.getInt(0);                Log.d(this.getClass().getName(), " ПолученныйПубличныйID  " + ПолученныйПубличныйID);                МетодПоказываетЗаблокированЛИПользовательИЛИнетСтатусОтСервера(Class_Engine_SQLГдеНаходитьсяМенеджерПотоков);            } else {                ПолученныйПубличныйID = 0;            }            ///TODO УСТАНАВЛИВАЕМ ФЛАГ ПРИ АУНТИФИКАЦИИ И МЯ И ПАРОЛЬ  СТАЫИМ ФЛАГ ОТКЛЮЧИТЬ ОБНОВЛЕНИЕ ПРИ СИНХРОНИЗАЦИИ false по умолчанию проверяем            //TODO и взапивсимости какой статус пришел мы показываем пользователю запуск в програму или перехода на имя и пвароль            Log.w(this.getClass().getName(), " ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ "+ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ);            Intent ИнтентДляЗапускаДляВизуализацииСинхронизации;            if(ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ==false                    || ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ==null) {                Integer РезультатПоказываетЧтоПользовательУспешноЗАходл =            МетодЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму();                Log.d(this.getClass().getName(), "  РезультатПоказываетЧтоПользовательУспешноЗАходл  " + РезультатПоказываетЧтоПользовательУспешноЗАходл);                String ПолученыйТекущееИмяПользователя = new Class_MODEL_synchronized(getApplicationContext()).МетодПолучениеИмяСистемыДляСменыПользователя(getApplicationContext());                Log.d(this.getClass().getName(), "  ПолученыйТекущееИмяПользователя  " + ПолученыйТекущееИмяПользователя);                textViewТекущийПользовательПРиВизуальнойСинхронизации.setText("пользователь: " + ПолученыйТекущееИмяПользователя.toUpperCase());                ИнтентДляЗапускаДляВизуализацииСинхронизации = new Intent(activity, MainActivity_Face_App.class);                ///TODO   конец ОБНУЛЕНИЯ ПЕРЕМЕННЫХ ПОСЛЕ УСПЕШНОЙ СИНХРНИЗАЦИИ ОБНУЛЯЕМ ВСЕ ПЕРЕМЕННЫЕ КОТОРЫЕ УЧАСТВОВАЛИ В СИНХРОНИЗАЦИИ            }else{                // TODO: 14.10.2021  когда пользователь временно заблокирован                // TODO: 14.10.2021  когда пользователь временно заблокирова                ИнтентДляЗапускаДляВизуализацииСинхронизации= new Intent(activity, MainActivity_Tabels_Users_And_Passwords.class);                Log.e(this.getClass().getName(), " Вы заблокированны обратитесь к Администатору ПО !!! ");                Toast.makeText(getApplicationContext(), "  Вы заблокированны обратитесь к Администатору ПО !!! " , Toast.LENGTH_LONG).show();            }            /////TODO после синхронизации обнуялем*/            ИнтентДляЗапускаДляВизуализацииСинхронизации.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP );// TODO: 01.12.2022   Записываем дама            SharedPreferences.Editor editor = preferences.edit();            editor.putString("РежимЗапускаСинхронизации","ПовторныйЗапускСинхронизации");            editor.commit();            startActivity(ИнтентДляЗапускаДляВизуализацииСинхронизации);            finishAfterTransition();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодБиндингаОбновлениеПО() {        try {            connectionОбновлениеПО = new ServiceConnection() {                @Override                public void onServiceConnected(ComponentName name, IBinder service) {                    try {                        if (service.isBinderAlive()) {                            // TODO: 28.07.2023                            AsyncTaskLoader<Boolean> asyncTaskLoaderБиндингAcynsAndPO=new AsyncTaskLoader<Boolean>(activity) {                                @Override                                protected void onStartLoading() {                                    super.onStartLoading();                                    try{                                        // TODO: 28.07.2023  Update                                        localBinderОбновлениеПО = (ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО) service;                                        Log.i(getApplicationContext().getClass().getName(), "    onServiceConnected  service)"                                                + service.isBinderAlive());                                        // TODO: 10.07.2023  запукскаем синхрониазцуию                                        ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна=          методЗапускаОбновлениеПоИзAsync();                                        Log.i(getApplicationContext().getClass().getName(), "    onServiceConnected  service)"                                                + service.isBinderAlive()+ " ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна "+ ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна);                                        if (ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна==false) {                                         cancelLoadInBackground();                                        }else {                                         forceLoad();                                        }                                        Log.d(getApplicationContext().getClass().getName(), "\n"                                            + " время: " + new Date() + "\n+" +                                            " Класс в процессе... " + this.getClass().getName() + "\n" +                                            " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                                            + " service.isBinderAlive() " +service.isBinderAlive());                                } catch (Exception e) {                                    e.printStackTrace();                                    Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                            " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                                    new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                            this.getClass().getName(),                                            Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                                }                                }                                @Override                                public void cancelLoadInBackground() {                                    super.cancelLoadInBackground();                                    try{                                        // TODO: 28.07.2023 выключаем                                   abandon();                                    Log.d(getApplicationContext().getClass().getName(), "\n"                                            + " время: " + new Date() + "\n+" +                                            " Класс в процессе... " + this.getClass().getName() + "\n" +                                            " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                                            + " service.isBinderAlive() " +service.isBinderAlive());                                } catch (Exception e) {                                    e.printStackTrace();                                    Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                            " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                                    new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                            this.getClass().getName(),                                            Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                                }                                }                                @Nullable                                @Override                                public Boolean loadInBackground() {                                    try{                                            // TODO: 18.05.2023  Главная Строчка Запуск Синхрниазциии                                            localBinderAsync.getService().metodStartingSync(activity,message);                                    Log.d(getApplicationContext().getClass().getName(), "\n"                                            + " время: " + new Date() + "\n+" +                                            " Класс в процессе... " + this.getClass().getName() + "\n" +                                            " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                                            + " service.isBinderAlive() " +service.isBinderAlive());                                } catch (Exception e) {                                    e.printStackTrace();                                    Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                            " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                                    new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                            this.getClass().getName(),                                            Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                                }                                    return ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна;                                }                            };                            asyncTaskLoaderБиндингAcynsAndPO.startLoading();                            asyncTaskLoaderБиндингAcynsAndPO.registerListener(new Random().nextInt(), new Loader.OnLoadCompleteListener<Boolean>() {                                @Override                                public void onLoadComplete(@NonNull Loader<Boolean> loader, @Nullable Boolean ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна) {                                    // TODO: 28.07.2023 метод после сихрониазции                                    try{                                            // TODO: 28.04.2023 выключаем службу                                            методUnBindingСлужбыОбновления();                                            // TODO: 27.10.2022  МетодАнализа Заблокирован или Нет пользователь и запуск Программы                                            МетодПослеСинхрониазцииЗапускаемИОцениваемПользователя();                                            Log.d(getApplicationContext().getClass().getName(), "\n"                                                    + " время: " + new Date() + "\n+" +                                                    " Класс в процессе... " + this.getClass().getName() + "\n" +                                                    " метод в процессе... " + Thread.currentThread().getStackTrace()[2].getMethodName()                                                    + " service.isBinderAlive() " +service.isBinderAlive()                                                    +  "  ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна " +ФлагЗАпускатьСинхронизациюПотосучтоВерсияРавна);                                            // TODO: 28.07.2023 exit                                            asyncTaskLoaderБиндингAcynsAndPO.abandon();                                    } catch (Exception e) {                                    e.printStackTrace();                                    Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                            + Thread.currentThread().getStackTrace()[2].getLineNumber());                                    new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                            this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                            Thread.currentThread().getStackTrace()[2].getLineNumber());                                }                                }                            });                        }                    } catch (Exception e) {                        e.printStackTrace();                        Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                        new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                this.getClass().getName(),                                Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                    }                }                @Override                public void onServiceDisconnected(ComponentName name) {                    try {                        localBinderОбновлениеПО=null;                        Log.i(getApplicationContext().getClass().getName(), "    onServiceDisconnected  binder.isBinderAlive()");                    } catch (Exception e) {                        e.printStackTrace();                        Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                                " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());                        new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                                this.getClass().getName(),                                Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());                    }                }            };            Intent intentЗапускСлужбыОбновлениеПО = new Intent(getApplicationContext(), ServiceUpdatePoОбновлениеПО.class);            intentЗапускСлужбыОбновлениеПО.setAction("com.ServiceUpdatePoОбновлениеПО");            Boolean asBoolenОбновлениеПО=         bindService(intentЗапускСлужбыОбновлениеПО , connectionОбновлениеПО,  Context.BIND_AUTO_CREATE );            // TODO: 28.04.2023            Log.d(this.getClass().getName(), "\n" + " class " +                    Thread.currentThread().getStackTrace()[2].getClassName()                    + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"  + " asBoolenОбновлениеПО " +asBoolenОбновлениеПО);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());            Log.d(this.getClass().getName(), "  Полусаем Ошибку e.toString() " + e.toString());        }    }}