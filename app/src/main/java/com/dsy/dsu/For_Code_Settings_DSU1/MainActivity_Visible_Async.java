package com.dsy.dsu.For_Code_Settings_DSU1;import android.app.Activity;import android.app.ActivityManager;import android.content.ComponentName;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.content.SharedPreferences;import android.content.pm.ActivityInfo;import android.database.sqlite.SQLiteCursor;import android.graphics.BlendMode;import android.graphics.Color;import android.graphics.PorterDuff;import android.graphics.drawable.Drawable;import android.os.Bundle;import android.os.Handler;import android.os.IBinder;import android.os.Looper;import android.os.Message;import android.os.Messenger;import android.util.Log;import android.view.Gravity;import android.view.MenuItem;import android.view.View;import android.view.WindowManager;import android.view.animation.Animation;import android.view.animation.AnimationUtils;import android.widget.ImageView;import android.widget.ProgressBar;import android.widget.TextView;import android.widget.Toast;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.constraintlayout.widget.ConstraintLayout;import androidx.drawerlayout.widget.DrawerLayout;import com.dsy.dsu.Business_logic_Only_Class.AllboundServices.AllBindingService;import com.dsy.dsu.Business_logic_Only_Class.CREATE_DATABASE;import com.dsy.dsu.Business_logic_Only_Class.Class_GRUD_SQL_Operations;import com.dsy.dsu.Business_logic_Only_Class.Class_Generation_Errors;import com.dsy.dsu.Business_logic_Only_Class.Class_MODEL_synchronized;import com.dsy.dsu.Business_logic_Only_Class.PUBLIC_CONTENT;import com.dsy.dsu.Code_For_Services.ServiceUpdatePoОбновлениеПО;import com.dsy.dsu.Code_For_Services.Service_For_Remote_Async;import com.dsy.dsu.R;import com.google.android.material.navigation.NavigationView;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.List;import java.util.Locale;import java.util.TimeZone;import java.util.concurrent.ExecutionException;public class MainActivity_Visible_Async extends AppCompatActivity  {    private   Date ДатаДляИзмененияВерсииДанныхНаАндройде;    private ProgressBar progressBar3ГоризонтальныйСинхронизации;    private  ProgressBar progressBarCycle;    private TextView ТекстВидBarСинх;    private TextView textViewТекущийПользовательПРиВизуальнойСинхронизации;    private Integer ПолученныйПубличныйID = 0;    private  Boolean  ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ=false;    private  CREATE_DATABASE Create_Database_СсылкаНАБазовыйКласс;    private  Activity activity;    private  String РежимПерваяЗапускПослеPasswordИлиПовторная = new String();    private   PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков = null;    private   Integer ПубличноеIDПолученныйИзСервлетаДляUUID = 0;    private DrawerLayout drawerLayoutAsync;    private NavigationView navigationViewAsyncApp;    private       ImageView imageView_ЗначекAsync;    private  ConstraintLayout constraintLayoutAsync;    private  TextView ТекущаяТаблицыИлиГод;    private SharedPreferences preferences;    private Animation animation;    private Message messagePingUpdatePO;    private ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО localBinderОбновлениеПО;//TODO нова    private    ServiceConnection serviceConnectionAsync;    private  Message message;    private Service_For_Remote_Async.LocalBinderAsync localBinderAsync;//TODO нова    @Override    protected void onCreate(Bundle savedInstanceState) {        try{            super.onCreate(savedInstanceState);            setContentView(R.layout.activity_main__sinfrozisaziy__prograssbar);            МетодСитемныйНастройкиЭкран();            // TODO: 15.09.2021 ПРИШЕЛ ПАРАМЕНТ КАКУЮ НУЖНО ЗАПИСТИТЬ СИНХРОНИЗАЦИЮ           // preferences = PreferenceManager.getDefaultSharedPreferences(this);            preferences = getSharedPreferences("sharedPreferencesХранилище", Context.MODE_MULTI_PROCESS);            Intent     Интент_AsyncApp=getIntent();            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT(getApplicationContext());            РежимПерваяЗапускПослеPasswordИлиПовторная = preferences.getString("РежимЗапускаСинхронизации","");            if(РежимПерваяЗапускПослеPasswordИлиПовторная==null){                РежимПерваяЗапускПослеPasswordИлиПовторная=  "СамыйПервыйЗапускСинхронизации";            }            ///TODO принудительно устанвливаем редим работы синхронизации            Log.d(this.getClass().getName(), " КакойРежимСинхрониазцииПерваяСинхронизациИлиПовторная "+ РежимПерваяЗапускПослеPasswordИлиПовторная);            Create_Database_СсылкаНАБазовыйКласс=new CREATE_DATABASE(getApplicationContext());            ///TODO КОНТЕКСТ КОТОРЫЙ ПЕРЕДАЮТ ПО ВСЕЙ СИНХРОНИЗАЦИИИ НА ВСЕ ПРИЛОЖЕНИЕ            activity =this;            ((Activity) activity).setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);            ((Activity) activity) .setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);            /////todo данная настрока запрещает при запуке активти подскаваать клавиатуре вверх на компонеты eedittext            //////todo  конец настрока экран////todo запрещает поворот экрана            Log.d(this.getClass().getName(), "Сработал  protected void onCreate(Bundle savedInstanceState)  MainActivity_Visible_Async" );            getSupportActionBar().hide(); ///скрывать тул бар            progressBarCycle =(ProgressBar) findViewById(R.id.progressBar4ПоКругуСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            progressBar3ГоризонтальныйСинхронизации =(ProgressBar) findViewById(R.id.progressBar3ГоризонтальныйСинхронизации);            progressBar3ГоризонтальныйСинхронизации.setVisibility(View.INVISIBLE);            ТекстВидBarСинх=(TextView) findViewById(R.id.TextViewДляProgressBarГлавнойСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            textViewТекущийПользовательПРиВизуальнойСинхронизации=(TextView) findViewById(R.id.textViewТекущийПользовательПРиВизуальнойСинхронизации); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            navigationViewAsyncApp    = (NavigationView) findViewById(R.id.navigator_asyncapp); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            imageView_ЗначекAsync = (ImageView) findViewById(R.id.imageView_icon_asynsapp);            drawerLayoutAsync = (DrawerLayout) findViewById(R.id.drawerLayout_async_prograsser); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            constraintLayoutAsync    = (ConstraintLayout) findViewById(R.id.constraintLayout_asynsprograsser);            drawerLayoutAsync.setBackgroundColor(Color.WHITE);         //TODO устанвливает цвета            constraintLayoutAsync.setBackgroundColor(Color.WHITE);            drawerLayoutAsync.setBackgroundColor(Color.WHITE);            drawerLayoutAsync.setDrawingCacheBackgroundColor(Color.RED);//todo            ТекущаяТаблицыИлиГод = (TextView) findViewById(R.id.TExtViewНазваниеКонторыСнизуСинх); /////КНОПКА ТАБЕЛЬНОГО УЧЕТА            // animation = AnimationUtils.loadAnimation(getContext(), R.anim.slide_in_row_vibrator1);            animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.slide_in_row_vibrator1);            // TODO: 25.10.2022 востанавливаем данных после поворота экрана            if(savedInstanceState!=null){                ТекстВидBarСинх.setText(savedInstanceState.getString("ТекстВидBarСинх"));                ТекущаяТаблицыИлиГод.setText(savedInstanceState.getString("ТекущаяТаблицыИлиГод"));                progressBar3ГоризонтальныйСинхронизации.setProgress(savedInstanceState.getInt("progressBar3ГоризонтальныйСинхронизации"));                progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(savedInstanceState.getInt("progressBar3ГоризонтальныйСинхронизацииback"));                progressBarCycle.setProgress(savedInstanceState.getInt("progressBar4Cycle"));                progressBarCycle.setMax(savedInstanceState.getInt("progressBar4CycleMAx"));            }            МетодБиндингаRemoteAsync();            // TODO: 09.10.2022 запуск слушателядоковой панели            МетодДляСлушательБоковойПанелиAsyncApp();            МетодДоНачалаСинхрониазцииExecutor();///TODO ДО СИНХРОНИАЗЦИИ            МетодБиндингаОбновлениеПО();            // TODO: 25.03.2023            Log.d(this.getClass().getName(),"\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber());        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    protected void onStop() {        super.onStop();        try{            Log.d(this.getClass().getName(), "\n" + " class " +                    Thread.currentThread().getStackTrace()[2].getClassName()                    + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void методUnBindingСлужбыОбновления() {        try {            if (localBinderОбновлениеПО!=null) {                localBinderОбновлениеПО=null;            }            if (localBinderAsync!=null) {                localBinderAsync=null;            }            if (serviceConnectionAsync!=null) {                unbindService(serviceConnectionAsync);            }            Log.d(this.getClass().getName(),"\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"  + " serviceConnectionAsync " +serviceConnectionAsync+                      " localBinderAsync "+ localBinderAsync + " localBinderОбновлениеПО  " +localBinderОбновлениеПО);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onDestroy() {        super.onDestroy();        try{            Log.d(this.getClass().getName(),"\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодБиндингаRemoteAsync() {        try {            ActivityManager am = (ActivityManager)this.getSystemService(ACTIVITY_SERVICE);            List<ActivityManager.RunningServiceInfo> ЗапущенныеСлужбы = am.getRunningServices(50);            if(ЗапущенныеСлужбы.size()==0){                // TODO: 28.04.2023  запускаем Гланвную Синхрониазцию                МетодИнициализацияMessager();                Intent intentОбноразоваяСинхронизациия = new Intent(getApplicationContext(), Service_For_Remote_Async.class);                serviceConnectionAsync=     new ServiceConnection() {                    @Override                    public void onServiceConnected(ComponentName name, IBinder service) {                        try{                            if (service.isBinderAlive()) {                                localBinderAsync = (Service_For_Remote_Async.LocalBinderAsync) service;                          Integer      ФинальныйРезультатAsyncBackgroud = localBinderAsync.getService().metodStartingSync(getApplicationContext(),message);                                Log.d(this.getClass().getName(), "\n" + " class " +                                        Thread.currentThread().getStackTrace()[2].getClassName()                                        + "\n" +                                        " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                                        " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                                        + " localBinderlocalBinderAsync.isBinderAlive()Async " + localBinderAsync.isBinderAlive() +                                        " ЗапущенныеСлужбы.size() " +ЗапущенныеСлужбы.size()                                        + " ФинальныйРезультатAsyncBackgroud " +ФинальныйРезультатAsyncBackgroud);                            }                        } catch (Exception e) {                            e.printStackTrace();                            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                    + Thread.currentThread().getStackTrace()[2].getLineNumber());                            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                    Thread.currentThread().getStackTrace()[2].getLineNumber());                        }                    }                    @Override                    public void onServiceDisconnected(ComponentName name) {                        localBinderAsync =null;                        Log.d(getApplicationContext().getClass().getName().toString(), "\n"                                + "onServiceConnected  одноразовая  messengerActivity  " );                    }                };         Boolean asBoolen=       bindService(intentОбноразоваяСинхронизациия,serviceConnectionAsync ,Context.BIND_AUTO_CREATE);                Log.d(getApplicationContext().getClass().getName().toString(), "\n"                        + "onServiceConnected  одноразовая  messengerActivity  asBoolen" +asBoolen);            }            // TODO: 28.04.2023            Log.d(this.getClass().getName(), "\n" + " class " +                    Thread.currentThread().getStackTrace()[2].getClassName()                    + "\n" +                    " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                    " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                    + " ЗапущенныеСлужбы.size() " + ЗапущенныеСлужбы.size());        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());            Log.d(this.getClass().getName(), "  Полусаем Ошибку e.toString() " + e.toString());        }    }    private void МетодСитемныйНастройкиЭкран() {        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD                | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);        //////todo настрока экрана        getWindow().getDecorView().setSystemUiVisibility(                View.SYSTEM_UI_FLAG_LAYOUT_STABLE                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION                        | View.SYSTEM_UI_FLAG_FULLSCREEN                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);        getSupportActionBar().setHomeButtonEnabled(false);        getSupportActionBar().setDisplayHomeAsUpEnabled(false);        getSupportActionBar().setHomeAsUpIndicator(null);    }    @Override    protected void onRestart() {        super.onRestart();        try {            if(preferences!=null){                МетодСитемныйНастройкиЭкран();                // TODO: 26.10.2022                МетодВостановлениеЭкранаПослеПоворота();            }            Log.d(this.getClass().getName(), "onRestart");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодВостановлениеЭкранаПослеПоворота() {        try{            ТекстВидBarСинх.setText(preferences.getString("ТекстВидBarСинх",""));            ТекстВидBarСинх.requestLayout();            ТекстВидBarСинх.forceLayout();            ТекстВидBarСинх.refreshDrawableState();            ТекущаяТаблицыИлиГод.setText(preferences.getString("ТекущаяТаблицыИлиГод",""));            ТекущаяТаблицыИлиГод.requestLayout();            ТекущаяТаблицыИлиГод.forceLayout();            ТекущаяТаблицыИлиГод.refreshDrawableState();            progressBar3ГоризонтальныйСинхронизации.setProgress(preferences.getInt("progressBar3ГоризонтальныйСинхронизации",0));            progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(preferences.getInt("progressBar3ГоризонтальныйСинхронизацииback",0));            progressBarCycle.setProgress(preferences.getInt("progressBar4Cycle",0));            progressBarCycle.setMax(preferences.getInt("progressBar4CycleMAx",0));            progressBar3ГоризонтальныйСинхронизации.requestLayout();            progressBar3ГоризонтальныйСинхронизации.forceLayout();            progressBar3ГоризонтальныйСинхронизации.refreshDrawableState();            progressBarCycle.refreshDrawableState();            // TODO: 26.10.2022            drawerLayoutAsync.forceLayout();            drawerLayoutAsync.refreshDrawableState();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onStart() {        super.onStart();//////TODO ловим поворот экрана  ДЛЯ СИНХРОНИЗАЦИИ        try{            МетодБоковаяПанельОткрытьЗАкрыть();            Log.i(this.getClass().getName(), "ДО  ОТРАБОТАННЙ СИНХРОНИЗАЦИИ ВИЗУАЛЬНОЙ doInBackground asyncTaskГлавныйДляСинхронизации ");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    protected void onResume() {        super.onResume();        try{        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(),                    Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 26.10.2022 сохраняет данные    protected void onSaveInstanceState(Bundle outState) {        try{            Log.i(this.getClass().getName(), "onSaveInstanceState ");            outState.putString("ТекстВидBarСинх",  ТекстВидBarСинх.getText().toString());            outState.putString("ТекущаяТаблицыИлиГод",  ТекущаяТаблицыИлиГод.getText().toString());            outState.putInt("progressBar3ГоризонтальныйСинхронизации", progressBar3ГоризонтальныйСинхронизации.getProgress());            outState.putInt("progressBar3ГоризонтальныйСинхронизацииback", progressBar3ГоризонтальныйСинхронизации.getSecondaryProgress());            outState.putInt("progressBar4Cycle",   progressBarCycle.getProgress());            outState.putInt("progressBar4CycleMAx",   progressBarCycle.getMax());            // TODO: 26.10.2022            SharedPreferences.Editor editor = preferences.edit();            editor.putString("ТекстВидBarСинх",   ТекстВидBarСинх.getText().toString());            editor.putString("ТекущаяТаблицыИлиГод", ТекущаяТаблицыИлиГод.getText().toString());            editor.putInt("progressBar3ГоризонтальныйСинхронизации", progressBar3ГоризонтальныйСинхронизации.getProgress());            editor.putInt("progressBar3ГоризонтальныйСинхронизацииback",  progressBar3ГоризонтальныйСинхронизации.getSecondaryProgress());            editor.putInt("progressBar4Cycle",   progressBarCycle.getProgress());            editor.putInt("progressBar4CycleMAx",   progressBarCycle.getMax());            editor.commit();// This will async            super.onSaveInstanceState(outState);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 26.10.2022 воставливает данные    protected void onRestoreInstanceState(Bundle savedInstanceState) {        super.onRestoreInstanceState(savedInstanceState);        try {            Log.i(this.getClass().getName(), "onRestoreInstanceState ");            МетодСитемныйНастройкиЭкран();            // TODO: 25.10.2022 востанавливаем данных после поворота экрана            МетодВостановлениеЭкранаПослеПоворота();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    @Override    public void onBackPressed()    {        //thats it    }    protected Integer МетодЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму() {        Integer Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации=0;        try{            ContentValues КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил = new ContentValues();            Date Дата = Calendar.getInstance().getTime();            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", new Locale("ru"));//"yyyy-MM-dd HH:mm:ss.SSS"//"yyyy-MM-dd'T'HH:mm:ss'Z'"            dateFormat.setTimeZone(TimeZone.getTimeZone("Europe/Moscow"));            Log.d(this.getClass().getName(), " ГЛАВНАЯ ДАТА ПРОГРАММЫ ДСУ-1 : " + dateFormat.format(Дата));            String ДатаДляПоказываетУспешнойСинхрониазцииЧтоПользовательЗаходилВпрограмму = dateFormat.format(Дата);            КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил.put("date_update", ДатаДляПоказываетУспешнойСинхрониазцииЧтоПользовательЗаходилВпрограмму);            Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ= new Class_GRUD_SQL_Operations(getApplicationContext());            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                    " SELECT id  FROM successlogin  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            PUBLIC_CONTENT  Class_Engine_SQLГдеНаходитьсяМенеджерПотоков =new PUBLIC_CONTENT (getApplicationContext());            SQLiteCursor            Курсор_ПолучаемПубличныйID= (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                    new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков                    ,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            if(Курсор_ПолучаемПубличныйID.getCount()>0){                Курсор_ПолучаемПубличныйID.moveToFirst();                ПубличноеIDПолученныйИзСервлетаДляUUID=         Курсор_ПолучаемПубличныйID.getInt(0);                Log.d(this.getClass().getName(), " ID  " + ПубличноеIDПолученныйИзСервлетаДляUUID);            }            Log.d(this.getClass().getName(), " ID  " + ПубличноеIDПолученныйИзСервлетаДляUUID);            if ( ПубличноеIDПолученныйИзСервлетаДляUUID>0) {                Class_GRUD_SQL_Operations class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму = new Class_GRUD_SQL_Operations(getApplicationContext());                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("НазваниеОбрабоатываемойТаблицы", "SuccessLogin");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("Флаг_ЧерезКакоеПолеОбновлением", "id");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ЗначениеФлагОбновления", ПубличноеIDПолученныйИзСервлетаДляUUID);                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ЗнакФлагОбновления", "=");                class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        contentValuesДляSQLBuilder_Для_GRUD_Операций.putAll(КонтейнерДляЗаписисВТалицуSuccessПриУспешнойСинхрониазцииПоказываетЧСТоПользовательЗаходил);                Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации = (Integer) class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.                        new UpdateData(getApplicationContext()).updatedata(class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                        class_grud_sql_operationsЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму.contentValuesДляSQLBuilder_Для_GRUD_Операций,                        Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());                Log.d(this.getClass().getName(), " Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации"                        + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);                // TODO: 08.09.2021  resultat                if (Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации > 0) {                    Log.d(getApplicationContext().getClass().getName(), " Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации " + "--"                            + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/////                } else {                    Log.d(getApplicationContext().getClass().getName(), " NO Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации " + "--"                            + Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации);/////                }            }        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        return  Результат_АдаптерДляДобавлениеПолученогоУспешноИмяиПарольДляСемидневнойАунтификации;    }    ///TODO вычисляем если такая таблиЦА ВНУТРИ БАЗЫ    protected boolean МетодВЫчисляемВсеТаблицыВнутриКлинета(String ТекущаяТаблицаДляОБменаДанными) {        ////        boolean ЕслиТАкаяТаблица = false;        ////        SQLiteCursor КурсорВсехТаблицВнутри=null;        try{            // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ            Class_GRUD_SQL_Operations     class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета=new Class_GRUD_SQL_Operations(getApplicationContext());            ///            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("НазваниеОбрабоатываемойТаблицы","sqlite_master");            ///////            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СтолбцыОбработки","name");            //            class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ФорматПосика","type = 'table' ");            ///"_id > ?   AND _id< ?"            //////             /*       class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска1",finalПолученныйUUID);                    ///                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска2","Удаленная");                    ///                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска3",МЕсяцДляКурсораТабелей);                    //                    class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеПоиска4",ГодДляКурсораТабелей);////УсловиеПоискаv4,........УсловиеПоискаv5 .......*/            ////TODO другие поля            ///classGrudSqlOperations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("ПоляГрупировки",null);            ////            //class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеГрупировки",null);            ////            // class_grud_sql_operationsПолучениеИмяСистемы. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеСортировки","date_update");            ////            /// class_grud_sql_operations. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("УсловиеЛимита","1");            ////            // TODO: 27.08.2021  ПОЛУЧЕНИЕ ДАННЫХ ОТ КЛАССА GRUD-ОПЕРАЦИИ            КурсорВсехТаблицВнутри=null;            КурсорВсехТаблицВнутри= (SQLiteCursor)  new Class_GRUD_SQL_Operations(getApplicationContext()).                    new GetData(getApplicationContext()).getdata(class_grud_sql_operationsВЫчисляемВсеТаблицыВнутриКлинета. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков                    ,Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            Log.d(this.getClass().getName(), "GetData "  +КурсорВсехТаблицВнутри);    /*            // TODO: 08.09.2021 ____old                /////              КурсорВсехТаблицВнутри=ССылкаНаСозданнуюБазу.rawQuery("SELECT name FROM sqlite_master WHERE type = 'table'",null);*/            // TODO: 08.09.2021 resultat            if(КурсорВсехТаблицВнутри.getCount()>0) {                КурсорВсехТаблицВнутри.moveToFirst();                Log.d(this.getClass().getName(), "  КурсорВсехТаблицВнутри."  +  КурсорВсехТаблицВнутри.getCount());                // TODO: 08.09.2021  цикл                do {                    ////                    if (ТекущаяТаблицаДляОБменаДанными.equals(КурсорВсехТаблицВнутри.getString(0))) {                        Log.d(this.getClass().getName(), "  ТекущаяТаблицаДляОБменаДанными." + ТекущаяТаблицаДляОБменаДанными +                                "  КурсорВсехТаблицВнутри.getString(0)) " + КурсорВсехТаблицВнутри.getString(0));                        ЕслиТАкаяТаблица = true;                        break;                    }                    Log.d(this.getClass().getName(), "  ТекущаяТаблицаДляОБменаДанными." + ТекущаяТаблицаДляОБменаДанными +                            "  КурсорВсехТаблицВнутри.getString(0)) " + КурсорВсехТаблицВнутри.getString(0));                }while(КурсорВсехТаблицВнутри.moveToNext());                ////////                КурсорВсехТаблицВнутри.close();            }else{                Log.d(this.getClass().getName(), "  КурсорВсехТаблицВнутри."  +  КурсорВсехТаблицВнутри.getCount());                //////                ЕслиТАкаяТаблица=false;            }            ///todo публикум название таблицы или цифру его        } catch (Exception e) {            //  Block of code to handle errors            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }////        return ЕслиТАкаяТаблица;    }    void МетодПоказываетЗаблокированЛИПользовательИЛИнетСтатусОтСервера(PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков) throws ExecutionException, InterruptedException {        try {            Class_GRUD_SQL_Operations class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ;            // TODO: 28.07.2022 проверка заблокирован ли пользователь или нет            //TODO  ПРОВЕРЯЕМ ТЕКУЩИЙ ПОЛЬЗОВАТЕЛЬ МОЖНО РАБОТАТЬ ИЛИ ОН ЗАБЛОКИРОВАН            ///            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ=new Class_GRUD_SQL_Operations(getApplicationContext());            // TODO: 26.08.2021 НОВЫЙ ВЫЗОВ НОВОГО КЛАСС GRUD - ОПЕРАЦИИ            ///            class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ. concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                    " SELECT locked  FROM chat_users  WHERE _id= '"+ПолученныйПубличныйID+"'  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            Integer ПолученныйСтатусТекущегоПользователя=0;            SQLiteCursor            Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором=null;            ///////            Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором=                    (SQLiteCursor) class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                            new GetаFreeData(getApplicationContext()).getfreedata(class_grud_sql_operationsПолучаемНаБазуUUIDфиоПолучаемИзТаблицыФИОИМЯ.                                    concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                            Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков,                            Create_Database_СсылкаНАБазовыйКласс.getССылкаНаСозданнуюБазу());            Log.d(this.getClass().getName(), " Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount() "                    +Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount());            if ( Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getCount()>0 ){                Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.moveToNext();                ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ= Boolean.parseBoolean(Курсор_ПолучаемСтатусТекущагоПользователяНеЗаблокированЛиОнАдминистатором.getString(0))        ;            }            // TODO: 28.07.2022            Log.d(this.getClass().getName(), " ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ "                    +ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ);        } catch (Exception e) {            //  Block of code to handle errors            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    void МетодДоНачалаСинхрониазцииExecutor() {        try{            ДатаДляИзмененияВерсииДанныхНаАндройде = Calendar.getInstance().getTime();            ТекстВидBarСинх.setVisibility(View.VISIBLE);            progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(2);            progressBar3ГоризонтальныйСинхронизации.getProgressDrawable().setColorFilter(                    Color.parseColor("#D81B60"), android.graphics.PorterDuff.Mode.SRC_IN);            progressBar3ГоризонтальныйСинхронизации.setIndeterminate(true);            progressBar3ГоризонтальныйСинхронизации.setProgress(0);            ТекстВидBarСинх.setText("0 %");           // progressBarCycle.getIndeterminateDrawable().setColorFilter(Color.RED, PorterDuff.Mode.SRC_IN);            Log.d(this.getClass().getName(), " onStartLoading() начало метода  ");        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() +                    " Линия  :" + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(),                    Thread.currentThread().getStackTrace()[2].getMethodName(), Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 02.09.2021  метод визуальной синхронмизации    private void МетодИнициализацияMessager() {        try{            message=Message.obtain(new Handler(Looper.myLooper()),()->{                Bundle bundle=   message.getData();                try {                    Integer dataSring=bundle.getInt("RemoteService");                    String СтатусРаботыСлужбыСинхронизации =bundle.getString("СтатусРаботыСлужбыСинхронизации");                    Integer МаксимальнеоКоличествоСтрок =bundle.getInt("МаксималноеКоличествоСтрочекJSON");                    Integer ФинальныйРезультатAsyncBackgroud =bundle.getInt("ФинальныйРезультатAsyncBackgroud");                    // TODO: 11.10.2022                    switch (СтатусРаботыСлужбыСинхронизации.trim()){                        case "ПроцессеAsyncBackground" :                            Log.w(this.getClass().getName(), "СтатусРаботыСлужбыСинхронизации  "+ СтатусРаботыСлужбыСинхронизации);                            // TODO: 11.10.2022  визиализируем ход синхронизации                            МетодВизуализацииСинхронизации(bundle);                            break;                        case "ФинишВыходИзAsyncBackground" :                            // TODO: 11.10.2022 выход из синхрониазхации конец                            МетодПослеСинхронизацииВизуальноеОформление(МаксимальнеоКоличествоСтрок);//TODO ПОСЛЕ СИНХРОНИЦИИ                            // TODO: 27.10.2022  МетодАнализа Заблокирован или Нет пользователь и запуск Программы                            МетодПослеСинхрониазцииОценкаПользователя();                            // TODO: 28.04.2023 выключаем службу                            методUnBindingСлужбыОбновления();                            Log.w(this.getClass().getName(), "СтатусРаботыСлужбыСинхронизации  "+ СтатусРаботыСлужбыСинхронизации);                            break;                    }                    Log.d(this.getClass().getName(),"\n" + " class " + Thread.currentThread().getStackTrace()[2].getClassName() + "\n" +                            " metod " + Thread.currentThread().getStackTrace()[2].getMethodName() + "\n" +                            " line " + Thread.currentThread().getStackTrace()[2].getLineNumber() + "\n"                            + " ФинальныйРезультатAsyncBackgroud "+ФинальныйРезультатAsyncBackgroud                            + " МаксимальнеоКоличествоСтрок " +МаксимальнеоКоличествоСтрок                            + " СтатусРаботыСлужбыСинхронизации"+СтатусРаботыСлужбыСинхронизации);                } catch (Exception e) {                    e.printStackTrace();                    Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                            + Thread.currentThread().getStackTrace()[2].getLineNumber());                    new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                            this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                            Thread.currentThread().getStackTrace()[2].getLineNumber());                }                Log.i(this.getClass().getName(),  " Атоманически установкаОбновление ПО "+                        Thread.currentThread().getStackTrace()[2].getMethodName()+                        " время " +new Date().toLocaleString() + " localBinderОбновлениеПО " +localBinderОбновлениеПО );            });        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодВизуализацииСинхронизации(Bundle data) {        try{            // TODO: 15.11.2022  первая часть            Integer МаксималноеКоличествоСтрочекJSON=        data.getInt("МаксималноеКоличествоСтрочекJSON");            if(МаксималноеКоличествоСтрочекJSON!=null){                progressBar3ГоризонтальныйСинхронизации.setMax(МаксималноеКоличествоСтрочекJSON);                progressBar3ГоризонтальныйСинхронизации.setMinHeight(5);              //  progressBar3ГоризонтальныйСинхронизации.setVisibility(View.VISIBLE);                // TODO: 17.11.2022                progressBarCycle.setMax(100);            }            Integer ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара=                    data.getInt("ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара",0);                Boolean ИндексРЕальнойВствкиИлилОбноывниевConetProver= data.getBoolean("РеальнаяРаботаВставкаОбновиеContProver",false);                Boolean ЧтоДелаемПолучаемДанныеИлиОтправляем= data.getBoolean("ЧтоДелаемПолучаемДанныеИлиОтправляем",false);                if (ИндексРЕальнойВствкиИлилОбноывниевConetProver==true) {                    // TODO: 15.11.2022  реальна вставка в базу                    progressBar3ГоризонтальныйСинхронизации.setIndeterminate(true);                    progressBar3ГоризонтальныйСинхронизации.getIndeterminateDrawable().setColorFilter(Color.GRAY, android.graphics.PorterDuff.Mode.SRC_IN);                   // progressBarCycle.getIndeterminateDrawable().setColorFilter(Color.GRAY, PorterDuff.Mode.SRC_IN);                }else {                    // TODO: 15.11.2022  наполение данными                    if (ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара>0) {                        progressBar3ГоризонтальныйСинхронизации.setIndeterminate(false);                        progressBar3ГоризонтальныйСинхронизации.getProgressDrawable().setColorFilter(  Color.parseColor("#00ACC1"), PorterDuff.Mode.SRC_IN);                     //   progressBarCycle.getIndeterminateDrawable().setColorFilter(Color.RED, PorterDuff.Mode.SRC_IN);                        if (progressBar3ГоризонтальныйСинхронизации.isAttachedToWindow()) {                            if (ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара == 0                                    && preferences.getInt("progressBar3ГоризонтальныйСинхронизации", 0) > 0) {                                progressBar3ГоризонтальныйСинхронизации.setProgress(preferences.getInt("progressBar3ГоризонтальныйСинхронизации", 0), true);                            } else {                                if (  progressBar3ГоризонтальныйСинхронизации.getMax()>ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара) {                                    progressBar3ГоризонтальныйСинхронизации.setProgress(ИндексТекущейОперацииJSONДляВизуальнойОбработкиНижнегоПрограссБара, true);                                    progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(progressBar3ГоризонтальныйСинхронизации.getProgress() * 2);                                }else{                                    МетодработыССетьюЗагрузкаВыгрузка(ЧтоДелаемПолучаемДанныеИлиОтправляем);                                    ТекстВидBarСинх.startAnimation(animation);                                }                            }                        }                    }else{                        МетодработыССетьюЗагрузкаВыгрузка(ЧтоДелаемПолучаемДанныеИлиОтправляем);                        ТекстВидBarСинх.startAnimation(animation);                    }                }            // TODO: 15.11.2022 вторая часть                        String имяТаблицыОтАндройда_локальноая=    data.getString("имяТаблицыОтАндройда_локальноая");            if (имяТаблицыОтАндройда_локальноая!=null) {                if (ТекущаяТаблицыИлиГод.isAttachedToWindow()) {                    if (ТекущаяТаблицыИлиГод.length()==0 && preferences.getString("ТекущаяТаблицыИлиГод","").length()>0) {                        ТекущаяТаблицыИлиГод.setHint(preferences.getString("ТекущаяТаблицыИлиГод",""));                    } else {                        ТекущаяТаблицыИлиГод.setHint(имяТаблицыОтАндройда_локальноая);                    }                }            }            String ПроцентыВерхнегоПрограссбара=    data.getString("ПроцентыВерхнегоПрограссбара");            if (ПроцентыВерхнегоПрограссбара!=null) {                if (ТекстВидBarСинх.isAttachedToWindow()) {                    if (ПроцентыВерхнегоПрограссбара.equalsIgnoreCase("0 %")                            && preferences.getString("ТекстВидBarСинх","").toString().length()>0) {                        ТекстВидBarСинх.setText(preferences.getString("ТекстВидBarСинх",""));                    } else {                        if (!ПроцентыВерхнегоПрограссбара.isEmpty()) {                            ТекстВидBarСинх.setText(ПроцентыВерхнегоПрограссбара);                            Integer ОбрабоатываемАтблицыПроценты= Integer.valueOf(ПроцентыВерхнегоПрограссбара.replaceAll("[^0-9]", ""));                            progressBarCycle.setProgress(ОбрабоатываемАтблицыПроценты);                        }                    }                }            }            progressBar3ГоризонтальныйСинхронизации.forceLayout();            progressBar3ГоризонтальныйСинхронизации.requestLayout();            progressBarCycle.forceLayout();            progressBarCycle.requestLayout();            ТекстВидBarСинх.forceLayout();            ТекстВидBarСинх.requestLayout();            drawerLayoutAsync.forceLayout();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодработыССетьюЗагрузкаВыгрузка(Boolean ЧтоДелаемПолучаемДанныеИлиОтправляем) {        progressBar3ГоризонтальныйСинхронизации.setIndeterminate(true);        if (ЧтоДелаемПолучаемДанныеИлиОтправляем ==true) {            progressBar3ГоризонтальныйСинхронизации.getIndeterminateDrawable().setColorFilter(Color.BLACK, PorterDuff.Mode.SRC_IN);            progressBar3ГоризонтальныйСинхронизации.setIndeterminateTintBlendMode(BlendMode.DARKEN);        }else {            progressBar3ГоризонтальныйСинхронизации.getIndeterminateDrawable().setColorFilter(Color.RED, PorterDuff.Mode.SRC_IN);            progressBar3ГоризонтальныйСинхронизации.setIndeterminateTintBlendMode(BlendMode.DARKEN);        }    }    private void МетодБоковаяПанельОткрытьЗАкрыть() {        try {            if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                drawerLayoutAsync.closeDrawer(Gravity.LEFT);            }        } catch (Exception e) {            e.printStackTrace();            ///метод запись ошибок в таблицу            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    // TODO: 03.04.2022    private void МетодДляСлушательБоковойПанелиAsyncApp() {        // TODO: 06.04.2022        try {            imageView_ЗначекAsync.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    if (navigationViewAsyncApp.isShown()) {                        navigationViewAsyncApp.setVisibility(View.GONE);                        if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                            drawerLayoutAsync.closeDrawer(Gravity.LEFT);                        }                    } else {                        navigationViewAsyncApp.setVisibility(View.VISIBLE);                        if (!drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                            drawerLayoutAsync.openDrawer(Gravity.LEFT);                        }                    }                }            });            drawerLayoutAsync.addDrawerListener(new DrawerLayout.SimpleDrawerListener() {                @Override                public void onDrawerOpened(View drawerView) {                    Drawable drawable = getResources().getDrawable(R.mipmap.icon_dsu1_for_asyncapp_close_naviga);///                    imageView_ЗначекAsync.setImageDrawable(drawable);                    navigationViewAsyncApp.setVisibility(View.VISIBLE);                    super.onDrawerOpened(drawerView);                }                @Override                public void onDrawerClosed(View drawerView) {                    Drawable drawable = getResources().getDrawable(R.drawable.icon_dsu1_async_asynprograssbar);///                    imageView_ЗначекAsync.setImageDrawable(drawable);                    navigationViewAsyncApp.setVisibility(View.GONE);                    super.onDrawerClosed(drawerView);                }            });            navigationViewAsyncApp.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {                @Override                public boolean onNavigationItemSelected(@NonNull MenuItem item) {                    switch (item.getItemId()) {                        // TODO: 06.04.2022 Запускаем ОШибки                        case R.id.one:                            item.setChecked(true);                            Log.w(getPackageName().getClass().getName(), "item.getItemId() Посмотреть ошибки   " + item.getItemId() + "\n");//////////                            try {                                Intent Интент_Меню = new Intent(getApplication(), MainActivity_Errors.class);                                Интент_Меню.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);//////FLAG_ACTIVITY_SINGLE_TOP                                Log.d(this.getClass().getName(), "" + "case R.id.ПунктМенюПервый:");                                startActivity(Интент_Меню);                                Log.i(this.getClass().getName(),  "R.id.one "+Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );                            } catch (Exception e) {                                e.printStackTrace();                                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                            break;                        // TODO: 06.04.2022 ЗапускаемОбновление ПО                        case R.id.item_async_updatepo:                            item.setChecked(true);                            try {                                localBinderОбновлениеПО.getService().МетодГлавныйОбновленияПО(true,activity);                                Log.i(this.getClass().getName(),  " Атоманически установкаОбновление ПО "+ Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );                                Log.w(getPackageName().getClass().getName(), "item.getItemId() Посмотреть ошибки   " + item.getItemId() + "\n");//////////                                Log.i(this.getClass().getName(),  "R.id.item_async_updatepo  "+Thread.currentThread().getStackTrace()[2].getMethodName()+ " время " +new Date().toLocaleString() );                            } catch (Exception e) {                                e.printStackTrace();                                Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                                        + Thread.currentThread().getStackTrace()[2].getLineNumber());                                new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                                        Thread.currentThread().getStackTrace()[2].getLineNumber());                            }                            break;                    }                    if (drawerLayoutAsync.isDrawerOpen(Gravity.LEFT)) {                        drawerLayoutAsync.closeDrawer(Gravity.LEFT);                    }                    return true;                }            });        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }        // TODO: 04.04.2022    }    ///TODO МЕТОД ПОСЛЕ ЗАВЕРШЕНИЯ РАБОТЫ В НИЖНЕМ ПОТОКЕ    public void МетодПослеСинхронизацииВизуальноеОформление(@NonNull Integer МаксимальнеоКоличествоСтрок) throws ExecutionException, InterruptedException {        Log.d(this.getClass().getName(), " КОНЕЦ синхронизация  onStopLoading()  ");        try {            // TODO: 22.11.2022 после синхронизации удаление данных со статусом Удаленой            // TODO: 27.10.2022  Удаляем Статус Удаленнаый            ТекстВидBarСинх.setText("100 %");            progressBar3ГоризонтальныйСинхронизации.setSecondaryProgress(2);            progressBar3ГоризонтальныйСинхронизации.getProgressDrawable().setColorFilter(                    Color.RED, android.graphics.PorterDuff.Mode.SRC_IN);            progressBar3ГоризонтальныйСинхронизации.setIndeterminate(true);            progressBar3ГоризонтальныйСинхронизации.setMax(МаксимальнеоКоличествоСтрок);            progressBar3ГоризонтальныйСинхронизации.setProgress(МаксимальнеоКоличествоСтрок);            Log.d(this.getClass().getName(), " ПолученныйПубличныйID  " + ПолученныйПубличныйID);        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодПослеСинхрониазцииОценкаПользователя() throws ExecutionException, InterruptedException {        Class_GRUD_SQL_Operations class_grud_sql_operations = new Class_GRUD_SQL_Operations(getApplicationContext());        МетодПослеСинхрониазцииЗапускаемИОцениваемПользователя(class_grud_sql_operations, Class_Engine_SQLГдеНаходитьсяМенеджерПотоков);    }    private void МетодПослеСинхрониазцииЗапускаемИОцениваемПользователя(Class_GRUD_SQL_Operations grudSqlOperations,                                                                        PUBLIC_CONTENT Class_Engine_SQLГдеНаходитьсяМенеджерПотоков)            throws ExecutionException, InterruptedException {        try{            grudSqlOperations.concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций.put("СамFreeSQLКОд",                    " SELECT id  FROM successlogin  ORDER BY date_update DESC ;");            // TODO: 12.10.2021  Ссылка Менеджер Потоков            SQLiteCursor Курсор_ПолучаемПубличныйID = null;            Курсор_ПолучаемПубличныйID = (SQLiteCursor) grudSqlOperations.                    new GetаFreeData(getApplicationContext()).getfreedata(grudSqlOperations.                            concurrentHashMapНаборПараментовSQLBuilder_Для_GRUD_Операций,                    Class_Engine_SQLГдеНаходитьсяМенеджерПотоков.МенеджерПотоков, new CREATE_DATABASE(getApplicationContext()).getССылкаНаСозданнуюБазу());            if (Курсор_ПолучаемПубличныйID.getCount() > 0) {                Курсор_ПолучаемПубличныйID.moveToFirst();                ПолученныйПубличныйID = Курсор_ПолучаемПубличныйID.getInt(0);                Log.d(this.getClass().getName(), " ПолученныйПубличныйID  " + ПолученныйПубличныйID);                МетодПоказываетЗаблокированЛИПользовательИЛИнетСтатусОтСервера(Class_Engine_SQLГдеНаходитьсяМенеджерПотоков);            } else {                ПолученныйПубличныйID = 0;            }            ///TODO УСТАНАВЛИВАЕМ ФЛАГ ПРИ АУНТИФИКАЦИИ И МЯ И ПАРОЛЬ  СТАЫИМ ФЛАГ ОТКЛЮЧИТЬ ОБНОВЛЕНИЕ ПРИ СИНХРОНИЗАЦИИ false по умолчанию проверяем            //TODO и взапивсимости какой статус пришел мы показываем пользователю запуск в програму или перехода на имя и пвароль            Log.w(this.getClass().getName(), " ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ "+ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ);            Intent ИнтентДляЗапускаДляВизуализацииСинхронизации;            if(ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ==false                    || ПолученныйCтатусЗАблокированЛИТЕкущйиПользовательИлНЕТ==null) {                Integer РезультатПоказываетЧтоПользовательУспешноЗАходл =            МетодЗАписываетНовуюДатуКогдаКлиентУспешноЗАходилВПрорамму();                Log.d(this.getClass().getName(), "  РезультатПоказываетЧтоПользовательУспешноЗАходл  " + РезультатПоказываетЧтоПользовательУспешноЗАходл);                String ПолученыйТекущееИмяПользователя = new Class_MODEL_synchronized(getApplicationContext()).МетодПолучениеИмяСистемыДляСменыПользователя(getApplicationContext());                Log.d(this.getClass().getName(), "  ПолученыйТекущееИмяПользователя  " + ПолученыйТекущееИмяПользователя);                textViewТекущийПользовательПРиВизуальнойСинхронизации.setText("пользователь: " + ПолученыйТекущееИмяПользователя.toUpperCase());                ИнтентДляЗапускаДляВизуализацииСинхронизации = new Intent(activity, MainActivity_Face_App.class);                ///TODO   конец ОБНУЛЕНИЯ ПЕРЕМЕННЫХ ПОСЛЕ УСПЕШНОЙ СИНХРНИЗАЦИИ ОБНУЛЯЕМ ВСЕ ПЕРЕМЕННЫЕ КОТОРЫЕ УЧАСТВОВАЛИ В СИНХРОНИЗАЦИИ            }else{                // TODO: 14.10.2021  когда пользователь временно заблокирован                // TODO: 14.10.2021  когда пользователь временно заблокирова                ИнтентДляЗапускаДляВизуализацииСинхронизации= new Intent(activity, MainActivity_Tabels_Users_And_Passwords.class);                Log.e(this.getClass().getName(), " Вы заблокированны обратитесь к Администатору ПО !!! ");                Toast.makeText(getApplicationContext(), "  Вы заблокированны обратитесь к Администатору ПО !!! " , Toast.LENGTH_LONG).show();            }            /////TODO после синхронизации обнуялем*/            ИнтентДляЗапускаДляВизуализацииСинхронизации.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP );// TODO: 01.12.2022   Записываем дама            SharedPreferences.Editor editor = preferences.edit();            editor.putString("РежимЗапускаСинхронизации","ПовторныйЗапускСинхронизации");            editor.commit();            startActivity(ИнтентДляЗапускаДляВизуализацииСинхронизации);            finishAfterTransition();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new   Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(),                    this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());        }    }    private void МетодБиндингаОбновлениеПО() {        try {            messagePingUpdatePO=Message.obtain(new Handler(Looper.myLooper()),()->{                Bundle bundle=   messagePingUpdatePO.getData();                localBinderОбновлениеПО= (ServiceUpdatePoОбновлениеПО.localBinderОбновлениеПО)  bundle.getBinder("allbinders")  ;                Log.i(this.getClass().getName(),  " Атоманически установкаОбновление ПО "+                        Thread.currentThread().getStackTrace()[2].getMethodName()+                        " время " +new Date().toLocaleString() + " localBinderОбновлениеПО " +localBinderОбновлениеПО );                Log.i(this.getClass().getName(), "bundle " +bundle);                messagePingUpdatePO.recycle();            });            // TODO: 27.03.2023 биндинг службы            new AllBindingService(getApplicationContext(), messagePingUpdatePO).МетодБиндингаОбновлениеПО();        } catch (Exception e) {            e.printStackTrace();            Log.e(this.getClass().getName(), "Ошибка " + e + " Метод :" + Thread.currentThread().getStackTrace()[2].getMethodName() + " Линия  :"                    + Thread.currentThread().getStackTrace()[2].getLineNumber());            new Class_Generation_Errors(getApplicationContext()).МетодЗаписиВЖурналНовойОшибки(e.toString(), this.getClass().getName(), Thread.currentThread().getStackTrace()[2].getMethodName(),                    Thread.currentThread().getStackTrace()[2].getLineNumber());            Log.d(this.getClass().getName(), "  Полусаем Ошибку e.toString() " + e.toString());        }    }}